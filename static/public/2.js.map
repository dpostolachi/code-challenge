{"version":3,"sources":["webpack:///../actions/search.js","webpack:///../components/pages/search.js","webpack:///../components/utils/routePromise.js"],"names":["resetSearch","dispatch","type","searchBand","bandName","ARTISTS_URL","API_KEY","then","resp","json","data","error","payload","catch","e","SearchPage","store","search","WithRoutePromises","props","getParams","location","query","state","pending","history","fetched","params","nextProps","prevState","newQuery","thisQuery","window","promises","push","PureComponent","RoutePromise","RoutePromiseProvider","Provider","Component"],"mappings":"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","file":"2.js","sourcesContent":["import { API_KEY, ARTISTS_URL } from 'settings/api'\nimport { get } from 'actions/utils'\n\n// Reset search\nexport const resetSearch = () => {\n\n    return ( dispatch ) => {\n\n        return dispatch( {\n            type: 'SEARCH_RESET',\n        } )\n\n    }\n}\n\n// Searching for band\nexport const searchBand = ( bandName ) => {\n\n    return ( dispatch ) => {\n\n        dispatch( {\n            type: 'SEARCH_PENDING'\n        } )\n\n        return get( `${ARTISTS_URL}/${bandName}?app_id=${API_KEY}` )\n        .then( ( resp ) => resp.json() )\n        .then( ( data ) => {\n            return ( data && !data.error ) ?\n                dispatch( {\n                    type: 'SEARCH_FULFILLED',\n                    payload: data,\n                } )\n            : dispatch( {\n                type: 'SEARCH_NO_RESULT',\n                payload: null,\n            } )\n        } )\n        .catch( (e ) => {\n            return dispatch( {\n                type: 'SEARCH_REJECTED',\n            } )\n        } )\n    }\n\n}\n","import React, { PureComponent } from 'react'\nimport { connect } from 'react-redux'\nimport styled, { keyframes } from 'styled-components'\nimport { parse } from 'query-string'\nimport { searchBand, resetSearch } from 'actions/search'\nimport BandThumb from 'components/blocks/bandThumb'\nimport Container from 'components/common/container'\nimport Heading from 'components/common/heading'\nimport LazyImage from 'components/common/lazyImage'\nimport SearchForm from 'components/controls/searchForm'\nimport ResultsContainer from 'components/common/resultsContainer'\nimport Placeholder from 'components/common/placeholder'\nimport { mainColor } from 'components/variables/colors'\nimport { WithRoutePromises } from 'components/utils/routePromise'\n\n@WithRoutePromises\n@connect( ( store ) => store.search )\n\nexport default class SearchPage extends PureComponent {\n\n    constructor ( props ) {\n\n        super( props )\n\n        const { query } = SearchPage.getParams( props.location.search )\n\n        this.state = {\n            query,\n        }\n\n    }\n\n    static getParams ( search ) {\n\n        const params = parse( search )\n\n        return {\n            query: params.query || ''\n        }\n\n    }\n\n    static getDerivedStateFromProps( nextProps, prevState ) {\n\n        const newQuery = SearchPage.getParams( nextProps.location.search ).query\n        const thisQuery = ( prevState ) ? prevState.query : null\n\n        const { fetched, pending } = nextProps\n\n        if ( newQuery !== thisQuery || ( !fetched && !pending ) ) {\n\n            // typeof window === 'undefined' is used to check if it's backend\n            if ( typeof window === 'undefined' && nextProps.promises !== null ) {\n                nextProps.promises.push( nextProps.dispatch( searchBand( newQuery ) ) )\n            } else {\n                nextProps.dispatch( searchBand( newQuery ) )\n            }\n        }\n\n        return {\n            query: newQuery\n        }\n    }\n\n    componentWillUnmount(){\n        // Reseting fetched and pending to false on unmount\n        return this.props.dispatch( resetSearch() )\n\n    }\n\n    render () {\n\n        const { query } = this.state\n        const { data, pending, history, fetched } = this.props\n        return (\n            <Container>\n                <SearchForm history={ history } query={ query } />\n                <Heading>Search result for \"{ query }\"</Heading>\n                <ResultsContainer className={ ( pending ) ? 'loading' : null }>\n                    {\n                        ( fetched && data ) ? (\n                            <BandThumb { ...data } />\n                        ) : (\n                            <Placeholder>{ ( !fetched ) ? 'Loading...' : 'No band found' }</Placeholder>\n                        )\n                    }\n                </ResultsContainer>\n            </Container>\n        )\n    }\n}\n","import React, { createContext } from 'react'\n\n/*\n\tUsed to collect fetch promises on backend and to resolve them\n*/\n\nconst RoutePromise = createContext( {\n\t// An array of promises to be resolved on backend before render\n\tpromises: [],\n} )\n\nexport const RoutePromiseProvider = RoutePromise.Provider\n\nexport const WithRoutePromises = ( Component ) => {\n\treturn ( props ) => {\n\t\treturn (\n\t\t\t<RoutePromise.Consumer>\n\t\t\t{\n\t\t\t\t( promises ) => {\n\t\t\t\t\treturn <Component { ...props } { ...promises } />\n\t\t\t\t}\n\t\t\t}\n\t\t\t</RoutePromise.Consumer>\n\t\t)\n\t}\n}\n"],"sourceRoot":""}